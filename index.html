
# coding: utf-8

# # CMSC320 Final Project (PokeAnalysis)

# # Jason Hauzel

# # Tutorial Content
# 
# [Introduction](#Introduction)
# 
# [Installing Libraries](#Install)
# 
# [Data Acquisition](#Data)
# 
# [Analysis and ML](#analysis)
# 
# [Conclusion](#conlusion)
# 
# [Future Outlook](#future)
# 
# [Sources](#sources)
# 

# <a id='Introduction'></a>
# # Introduction
# 
# Ever since its creation in 1995, Pokemon has become a common household name all around the world. One of the largest contributors to its popularity are the video games, which first released in 1998 on GameBoy and GameBoy Color. Although the game has simple RPG (Role-Playing Game) elements akin to all games in the genre, there are quite a few hidden and complex mechanics involved that make the gameplay fun and interesting for everyone.
# 
# In this tutorial we will talk about some of these mechanics and how they affect gameplay, as well as how these mechanics have changed over the generations. We will do this by first collecting data on the first six generations of the Pokemon video games, processing the data to understand/visualize it, and finally utilize machine learning to analyze the complexities involved in the Pokemon games and how it has changed over time.

# <a id='Install'></a>
# # Installing Libraries
# 
# Here are few libraries I will be using throughout this tutorial.
# 
# `$ pip install numpy`
# 
# `$ pip install scipy`
# 
# `$ pip install scikit-learn`
# 
# `$ pip install pandas`
# 

# <a id='Data'></a>
# # Data Acuisition
# 
# The data used here will be from a pokemon database on kaggle.com
# 
# After importing the necessary libraries, we can read in cvs files using the pandas function read_csv

# In[215]:

# Importing libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib

pokeDex = pd.read_csv("Pokemon.csv")
pokeDex.head()


# Here I've created the pokeDex object of type pandas.DataFrame. It stores the data in an array-like matrix with column and row values as values that can be used to manipulate the data. 
# 
# As we can see, the dataset contains the name, type, stats and other information about each pokemon. 
# 
# With each new generation of pokemon, there is an introduction of new mechanics. One of them being Mega evolutions and Primal versions of pokemon. For this dataset, it considers these new features as part of the old generation but I will have it so each pokemon version is associated with the generation it was introduced in.

# In[216]:

import re

def is_mega_primal(row):
    mega = re.search('Mega', row['Name'])
    primal = re.search('Primal', row['Name'])
    if mega or primal:
        row['Generation'] = 6
        
    #for i,v in row.iteritems():
        #print(type(v))
    return row

pokeDex = pokeDex.apply(lambda x: is_mega_primal(x), axis=1)
pokeDex.head()


# Now that we've corrected some parts of our data, we can add more to it. 
# 
# In the pokemon video games, all the player typically sees when assess his/her pokemon are the statistics (i.e. HP, Attack, Defense, etc...). Unbeknownst to most players, there is actually more to what goes behind calculating each stat and thus the total power of the pokemon.
# 
# The first hidden mechanic is called an Individual Value (IV), which is the pokemon's inherent value for each stat. IV's take a value anywhere in the range of 0-31, and when a pokemon reaches level 100, the IV is added on top of the Base stat. In the game, the value is randomly assigned, meaning each pokemon is not created equal and it could make the difference between winning or losing a fight. There are certain ways to obtain pokemon with high IV's but mostly through chance. 
# 
# Additionally, there is a mechanic called Effort Values (EV), which taken into consideration which pokemon have been fought. These values also add onto each Base stat and increases the overall power level of the pokemon. Certain pokemon, when fought, give an EV for a particular stat. For example, say your pikachu battles and defeats an Ekans (wild or trainer), then it will get +1 EV towards its Attack stat because that is the stat Ekans modifies. Four EV's for a given stat equate to an increase by 1 of the overall stat. Each pokemon can gain a total of 510 EV points but only 255 towards any given stat. 
# 
# For generation I and II, calculation of total stat is done by "Oak's Theorem", and by "Birch's Theorem" for gen III and above. Additionally, the HP stat is calculated differently from the other stats by each Theorem.
# 
# ### Oak's Theorem:
# 
# $$\rho_{HP} = \frac{(2(B+I)+\frac{\sqrt{\sigma}}{4})*\alpha}{100} + \alpha + 10$$
# $$\rho_{stat} = \frac{(2(B+I)+\frac{\sqrt{\sigma}}{4})*\alpha}{100} + 5$$
# 
# ### Birch's Theorem:
# 
# $$\Gamma_{HP} = \frac{(2BI+\frac{\sigma}{4})*\alpha}{100} + \alpha + 10$$
# $$\Gamma_{stat} = (\frac{(2BI+\frac{\sigma}{4})*\alpha}{100} + 5)\phi$$
# 
# B = Base stat
# I = Individual Value
# $\sigma$ = Effort Value
# $\alpha$ = Level
# $\phi$ = Nature
# 
# Note: In gen III and above a feature called nature was created that determines a multiplier for 2 stats, increasing one by 1.1 and decreasing another by 0.9. I will keep it as 1 (the benign nature) in the rest of the tutorial to make comparisons between generations more accurate.
# 
# Now, in order to properly assess the [meta](https://en.wikipedia.org/wiki/Metagaming) of types between generations, I will maximize all the stats for each pokemon. Using the Base stats in the given dataset I will give a max IV of 31 for each stat, have a level of 100, and distribute EV's to the highest Base stats. Since only 255 EV's can be given to any one stat, and you need 4 to accumulate a point, it is useful to get 252 (63 points) to one stat since the last 3 would be wasted. So I can give 63 points to two stats and 1 point to one other stat with a remainder of 2 EV's leftover.
# 
# $63*2*2 + 4*1 + 2 = 510$
# 
# Note: In gen I and II, there is a root function for the EV's but not in gen III onward. This is because EV's were represented as values on a larger scale, from 0-510^2. So to make calculations easier I have ommitted the root function to use the normal values instead in the following code.

# In[217]:

# import math library
import math

# define parameters for max stats
IV = 31
Level = 100


# max stat calculation for gen I and II
def Omax(base, stype, num):
    
    EV = num
    
    if stype == 'HP':
        return int(((2*(base + IV) + (EV / 4))*Level / 100) + Level + 10)
    else:
        return int(((2*(base + IV) + (EV / 4))*Level / 100) + 5)

# max stat calculation for gen III+
def Bmax(base, stype, num):

    EV = num
    
    if stype == 'HP':
        return int(((2*base + IV + (EV / 4))*Level / 100) + Level + 10)
    else:
        return int(((2*base + IV + (EV / 4))*Level / 100) + 5)
    
# maximize stats for given pokemon row
def max_stats(row):

    gen = row['Generation']
    stats = {}
    stats['HP'] = row['HP']
    stats['Attack'] = row['Attack']
    stats['Defense'] = row['Defense']
    stats['Sp. Atk'] = row['Sp. Atk']
    stats['Sp. Def'] = row['Sp. Def']
    stats['Speed'] = row['Speed']
    
    vals = []
    for k,v in stats.items():
        vals.append(v)
    
    max1 = max(vals)
    vals.remove(max1)
    
    max2 = max(vals)
    vals.remove(max2)
    
    max3 = max(vals)
    vals.remove(max3)
    
    i = 0
    for k,v in stats.items():
        
        c = 0
        if v == max1 or v == max2:
            c = 252
        elif v == max3:
            c = 6
        if c != 0:
            i += 1
            if gen < 3:
                row[k] = Omax(v,k,c)
            else:
                row[k] = Bmax(v,k,c)
        if i == 3:
            break
    row['Total'] = row['HP'] + row['Attack'] + row['Defense'] + row['Sp. Atk'] + row['Sp. Def'] + row['Speed']
    return row
    
   
pokeDex = pokeDex.apply(lambda x: max_stats(x), axis = 1)
pokeDex.head(50)


# Now that we have maxed out each pokemon in their respective generations stat, we can properly compare different types within each generation and see which type, on average is the strongest. We will do this comparison using the Total column as our estimator for power levels for any given pokemon.
# 
# To do this, we can use the properties of pandas dataframe to group each row based on some value, function, mapping, etc... In this case we will group them by the column 'Generation'.

# In[218]:

gens = pokeDex.groupby(by=pokeDex['Generation'])
for name in gens.groups:
    print(name)


# Here we can see that we have 6 groups, corresponding to each gen. Next, in order to compute the average power level of each type in each group, we can group by the 'Generation' and 'Type 1' columns. This will split each gen into subcategories corresponding to each pokemons' main type. We can also then find the average by simply calling the mean function on the 'Total' column for each of these groups.

# In[219]:

gen_type = pokeDex.groupby(['Generation','Type 1'])
for name, group in gen_type.groups:
    mean = gen_type.get_group((name, group))['Total'].mean()
    print((name, group), ':' , mean)


# This is now a list of average total power for each type in each generation. For a more natural look, we can plot this information as a bar graph to compare the rankings of types within each gen.

# In[222]:

# create plot object
bar_width = 0.5
opacity = 0.8

# index for each type per gen
gen1_types = []
gen1_means = []
gen2_types = []
gen2_means = []
gen3_types = []
gen3_means = []
gen4_types = []
gen4_means = []
gen5_types = []
gen5_means = []
gen6_types = []
gen6_means = []

# sort mean of each type and type per gen
for name, group in gen_type.groups:
    if name == 1:
        gen1_types.append(group)
        gen1_means.append(gen_type.get_group((name, group))['Total'].mean())
    elif name == 2:
        gen2_types.append(group)
        gen2_means.append(gen_type.get_group((name, group))['Total'].mean())
    elif name == 3:
        gen3_types.append(group)
        gen3_means.append(gen_type.get_group((name, group))['Total'].mean())
    elif name == 4:
        gen4_types.append(group)
        gen4_means.append(gen_type.get_group((name, group))['Total'].mean())
    elif name == 5:
        gen5_types.append(group)
        gen5_means.append(gen_type.get_group((name, group))['Total'].mean())
    elif name == 6:
        gen6_types.append(group)
        gen6_means.append(gen_type.get_group((name, group))['Total'].mean())

# plotting each type for each gen
for x in range(1,7):
    f, ax = plt.subplots()
    if x == 1:
        plt.bar(np.arange(len(gen1_means)), gen1_means, bar_width, alpha=opacity, color='R')
        ax.set_title('Generation 1 Type Comparisons')
        ax.set_xticks(np.arange(len(gen1_means) + bar_width / 2))
        ax.set_xticklabels(gen1_types, rotation='vertical')
    if x == 2:
        plt.bar(np.arange(len(gen2_means)), gen2_means, bar_width, alpha=opacity, color='G')
        ax.set_title('Generation 2 Type Comparisons')
        ax.set_xticks(np.arange(len(gen2_means) + bar_width / 2))
        ax.set_xticklabels(gen2_types, rotation='vertical')
    if x == 3:
        plt.bar(np.arange(len(gen3_means)), gen3_means, bar_width, alpha=opacity, color='B')
        ax.set_title('Generation 3 Type Comparisons')
        ax.set_xticks(np.arange(len(gen3_means) + bar_width / 2))
        ax.set_xticklabels(gen3_types, rotation='vertical')
    if x == 4:
        plt.bar(np.arange(len(gen4_means)), gen4_means, bar_width, alpha=opacity, color='Y')
        ax.set_title('Generation 4 Type Comparisons')
        ax.set_xticks(np.arange(len(gen4_means) + bar_width / 2))
        ax.set_xticklabels(gen4_types, rotation='vertical')
    if x == 5:
        plt.bar(np.arange(len(gen5_means)), gen5_means, bar_width, alpha=opacity, color='Cyan')
        ax.set_title('Generation 5 Type Comparisons')
        ax.set_xticks(np.arange(len(gen5_means) + bar_width / 2))
        ax.set_xticklabels(gen5_types, rotation='vertical')
    if x == 6:
        plt.bar(np.arange(len(gen6_means)), gen6_means, bar_width, alpha=opacity, color='Purple')
        ax.set_title('Generation 6 Type Comparisons')
        ax.set_xticks(np.arange(len(gen6_means) + bar_width / 2))
        ax.set_xticklabels(gen6_types, rotation='vertical')
                      
    ax.set_ylabel('Average Total Power')
plt.show()


# <a id='analysis'></a>
# # Analysis and Machine Learning
# 
# In order to make games that are repeated interations of their predecessors, something new has to be introduced. In pokemon, what changes is which types are the most powerful from generation to generation. This makes it so the in-game, and real-world competitive gaming competition doesn't turn stale and instead becomes dynamic. 
# 
# Now that we have seen the meta for each of the generations, we will observe the change of the meta over the generations. We will do this by finding the strongest of each type per generation and seeing how they all changed from generation to generation. My null hypothesis will be that there is no significant difference in power level from generation to generation and my alternative will be that there is. We can decide whether or not to reject the null by creating a linear regression line for each of the strongest types from each generation and plot the average power level over the generations. Evidence for rejecting the null will produce lines with positive or negative values. If we obtain relatively straight lines, there will not be enough evidence to reject the null.
# 
# From visual inspection it looks as though this is the case:
# 
# 
# 
# Gen 1: Ice 
# 
# Gen 2: Poison
# 
# Gen 3: Dragon
# 
# Gen 4: Ghost
# 
# Gen 5: Dragon
# 
# Gen 6: Ground
# 
# 
# 
# 
# We can then confirm by finding the actual values and comparing.
# 
# Note: There are some types that do not appear in certain generations, but from our data, all of the strongest types belong to all generations. So this issue will not come into play for our analysis

# In[175]:

strongest = {}

for name, group in gen_type.groups:
    mean = gen_type.get_group((name, group))['Total'].mean()
    if name in strongest:
        if strongest[name][1] < mean:
            strongest[name] = [group, mean]
    else:
        strongest[name] = [group, mean]
        
strongest


# As we suspected from our visual inspection, the strongest types are Ice, Poison, Dragon, Ghost, and Ground.
# 
# Next, I will calculate a new Total power level for each of the strongest Base stats for each pokemon. I will do this by creating a fucntion to calculate the new stat with either Oak's or Birch's Theorem. Then after calculating these values, we can using them for the linear regression analysis with help from the scipy and sklearn libraries.

# In[294]:

from scipy import stats
from sklearn import linear_model as lin

strongest_types = []

strongest_values = [{},{},{},{},{},{}]

for k,v in strongest.items():
    if v[0] not in strongest_types:
        strongest_types.append(v[0])
        for dic in strongest_values:
            dic[v[0]] = []

for gen in gens.groups:
    data = gens.get_group(gen)
    i = gen-1
    dic = strongest_values[i]
    for k,v in dic.items():
        d1 = data[data['Type 1'] == k]
        dic[k] = d1['Total'].tolist()
        
def append_data(x, d, t):
    for i in d:
        for k,v in i.items():
            if k == t:
                x.append(v)
    return x

index = [1,2,3,4,5,6]

            
for t in strongest_types:
    f, ax = plt.subplots()
    c = 0
    y = []
    x = []

    if t == 'Ice':

        for i in strongest_values:
            c += 1
            for k,v in i.items():
                if k == t:
                    y.extend(v)
                    z = [c for b in range(len(v))]
                    x.extend(z)
    if t == 'Poison':
        for i in strongest_values:
            c += 1
            for k,v in i.items():
                if k == t:
                    y.extend(v)
                    z = [c for b in range(len(v))]
                    x.extend(z)
    if t == 'Dragon':
        for i in strongest_values:
            c += 1
            for k,v in i.items():
                if k == t:
                    y.extend(v)
                    z = [c for b in range(len(v))]
                    x.extend(z)

    if t == 'Ghost':
        for i in strongest_values:
            c += 1
            for k,v in i.items():
                if k == t:
                    y.extend(v)
                    z = [c for b in range(len(v))]
                    x.extend(z)
    if t == 'Ground':
        for i in strongest_values:
            c += 1
            for k,v in i.items():
                if k == t:
                    y.extend(v)
                    z = [c for b in range(len(v))]
                    x.extend(z)

    slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)
    line = slope*np.array(x) + intercept
        
    ax.scatter(x,y)
    ax.set_title(t+' Type')
    ax.set_xlabel('Generation')
    ax.set_ylabel('Total Power')
        
    x1 = np.array(x)
    y1 = np.array(y)
    ax.plot(x1,y1,'o',x,line)
    print('slope: ', slope,'intercept: ', intercept,'r_value: ', r_value,'p_value: ', p_value,'std_err: ', std_err)
            


plt.show()


# If we are to assume a confidence interval of 95% with an $\alpha$ of 0.05, the p-value from each of the models does not provide sufficient evidence to reject the null hypothesis. Therefore we cannot conclude that, on average, there is a significant difference in power level of the strongest types from each generation from generation to generation. 

# <a id='conclusion'></a>
# # Conclusion
# 
# Based on the linear regression models, even though the stronest types can change from generation to generation, there is not a significant power level difference between the generations. From our first models that compared different types within each generation, we can see that even though there might be some differences between average power levels, the distribution is quite uniform. For generation 6, ground typed looked significantly different but there was only one data point, effectively skewing the graph. 
# 
# In actuality, this conclusion makes some sense. If the makers of the pokemon video games wish to keep the game fun and interesting, there must be new metas created. And although the meta changes from generation to generation, the difference between the strongest types between generations do not have a significant difference in power levels. This is a good approach to game making since if one type becomes too powerful, it must be fixed by either lowering the overall power level or increasing the power level of other types. The game makers have achieved a good overall fair system for introducing new pokemon every generation without completely overpowering or underpowering the different types.

# <a id='future'></a>
# # Future Outlook
# 
# Our analysis looked at only the main type (Type 1) of each pokemon, even though there exist some pokemon with dual types. This might have led to skewed or statistically unsound results. The issue here is that when comparing average power levels, using a pokemon in more than one computation for a given type also seems statistically unsound. A better approach might be to classify each dual type as their own category, but this then leads to the problems of taking them out of other categories creating an effect of having fewer data points for any given type. This problem of finding the correct way to measure power levels based on types and considering dual types is still an issue and is worth looking into for future studies.
# 
# Additionally, the analysis provided does not consider type advantages and weaknesses. For example, if a fire type was the strongest for any given generation, but there was a water type (water is super-effective against fire, and fire not-effective against water), that was close behind in terms of power level, it is arguable to say that the water type should be the strongest. This serves as another way for the game makers to add complexity to the game. Since if one type is too strong in one generation, they can introduce a new type or even a dual typed pokemon to counter this without breaking the meta. For example, in gen 1, it is known that psychic types were some of the most powerful pokemon, but in gen 2, dark types were introduced. Since psychic types were weak against dark types, they weren't as powerful before in the newer generations. But to make sure dark types weren't overpowered, they were weak against fighting types and fighting types were weak against psychic types. This effectively created an advantage triangle and made sure that new types introduced weren't overpowered. In future studies it would also be appropriate to consider the type advatanges as well.

# <a id='sources'></a>
# # Sources
# 
# Here is a list of sources used in this tutorial:
# 
# [Anaconda](https://anaconda.org/)
# 
# [Jupyter Notebook](http://jupyter.org/)
# 
# [Matplotlib](http://matplotlib.org/)
# 
# [Numpy](http://www.numpy.org/)
# 
# [Pandas](https://pandas.pydata.org/)
# 
# [Scipy](https://www.scipy.org/)
# 
# [Scikit-learn](http://scikit-learn.org/stable/)
# 
# [Regular Expressions](https://docs.python.org/3.4/library/re.html)
# 
# [Pokemon Database](https://www.kaggle.com/abcsds/pokemon)
# 
# [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Main_Page)
# 
# [Pokemondb](https://pokemondb.net/ev)

# In[ ]:



